<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>lua基础 | pixel博客</title><meta name="author" content="pixel"><meta name="copyright" content="pixel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介Lua的设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。   作为一门过程型动态语言，Lua有着如下的特性：  变量名没有类型，值才有类型，变量名在运行时可与任何类型的值绑定; 语言只提供唯一一种数据结构，称为表(table)，它混合了数组、哈希，可以用任何类型的值作为 key 和 value。提供了一致且富有表达力的表构造语法，使得 Lua 很适合描述复杂的数据; 函数">
<meta property="og:type" content="article">
<meta property="og:title" content="lua基础">
<meta property="og:url" content="http://example.com/2025/02/07/lua%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="pixel博客">
<meta property="og:description" content="简介Lua的设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。   作为一门过程型动态语言，Lua有着如下的特性：  变量名没有类型，值才有类型，变量名在运行时可与任何类型的值绑定; 语言只提供唯一一种数据结构，称为表(table)，它混合了数组、哈希，可以用任何类型的值作为 key 和 value。提供了一致且富有表达力的表构造语法，使得 Lua 很适合描述复杂的数据; 函数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/lbxx.png">
<meta property="article:published_time" content="2025-02-07T10:45:45.000Z">
<meta property="article:modified_time" content="2025-02-07T11:09:31.463Z">
<meta property="article:author" content="pixel">
<meta property="article:tag" content="脚本语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/lbxx.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "lua基础",
  "url": "http://example.com/2025/02/07/lua%E5%9F%BA%E7%A1%80/",
  "image": "http://example.com/image/lbxx.png",
  "datePublished": "2025-02-07T10:45:45.000Z",
  "dateModified": "2025-02-07T11:09:31.463Z",
  "author": [
    {
      "@type": "Person",
      "name": "pixel",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/lbxx.png"><link rel="canonical" href="http://example.com/2025/02/07/lua%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'lua基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/styles/main.css"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">pixel博客</span></a><a class="nav-page-title" href="/"><span class="site-name">lua基础</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">lua基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-07T10:45:45.000Z" title="发表于 2025-02-07 18:45:45">2025-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-07T11:09:31.463Z" title="更新于 2025-02-07 19:09:31">2025-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Lua的设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。  </p>
<p>作为一门过程型动态语言，Lua有着如下的特性：</p>
<ul>
<li>变量名没有类型，值才有类型，变量名在运行时可与任何类型的值绑定;</li>
<li>语言只提供唯一一种数据结构，称为表(table)，它混合了数组、哈希，可以用任何类型的值作为 key 和 value。提供了一致且富有表达力的表构造语法，使得 Lua 很适合描述复杂的数据;</li>
<li>函数是一等类型，支持匿名函数和正则尾递归(proper tail recursion);</li>
<li>支持词法定界(lexical scoping)和闭包(closure);</li>
<li>提供 thread 类型和结构化的协程(coroutine)机制，在此基础上可方便实现协作式多任务;</li>
<li>运行期能编译字符串形式的程序文本并载入虚拟机执行;</li>
<li>通过元表(metatable)和元方法(metamethod)提供动态元机制(dynamic metamechanism)，从而允许程序运行时根据需要改变或扩充语法设施的内定语义;</li>
<li>能方便地利用表和动态元机制实现基于原型(prototype-based)的面向对象模型;</li>
<li>从 5.1 版开始提供了完善的模块机制，从而更好地支持开发大型的应用程序;</li>
</ul>
<p>Lua应用场景：</p>
<ul>
<li>游戏开发</li>
<li>独立应用脚本</li>
<li>Web 应用脚本</li>
<li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li>
<li>安全系统，如入侵检测系统</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Lua最新版本是Lua 5.3.4（截止到2018-3-18）。  </p>
<p>官网：<a target="_blank" rel="noopener" href="http://www.lua.org/">http://www.lua.org/</a></p>
<h3 id="Linux-系统上安装"><a href="#Linux-系统上安装" class="headerlink" title="Linux 系统上安装"></a>Linux 系统上安装</h3><p>Linux &amp; Mac上安装 Lua 安装非常简单，只需要下载源码包并在终端解压编译即可，本文使用了5.3.0版本进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="Mac-OS-X-系统上安装"><a href="#Mac-OS-X-系统上安装" class="headerlink" title="Mac OS X 系统上安装"></a>Mac OS X 系统上安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make macosx test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>Mac 上也可以通过 homebrew 安装:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lua</span><br></pre></td></tr></table></figure>

<h3 id="Window-系统上安装-Lua"><a href="#Window-系统上安装-Lua" class="headerlink" title="Window 系统上安装 Lua"></a>Window 系统上安装 Lua</h3><p>window下你可以使用一个叫”SciTE”的IDE环境来执行lua程序，下载地址为：<br>Github 下载地址：<a target="_blank" rel="noopener" href="https://github.com/rjpcomputing/luaforwindows/releases">https://github.com/rjpcomputing/luaforwindows/releases</a><br>Google Code下载地址 : <a target="_blank" rel="noopener" href="https://code.google.com/p/luaforwindows/downloads/list">https://code.google.com/p/luaforwindows/downloads/list</a><br>双击安装后即可在该环境下编写 Lua 程序并运行。</p>
<p>你也可以使用 Lua 官方推荐的方法使用 LuaDist：<a target="_blank" rel="noopener" href="http://luadist.org/">http://luadist.org/</a></p>
<p>安装好后查看版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lua -v</span><br><span class="line">Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio</span><br></pre></td></tr></table></figure>

<h3 id="Lua-和-LuaJIT-的区别"><a href="#Lua-和-LuaJIT-的区别" class="headerlink" title="Lua 和 LuaJIT 的区别"></a>Lua 和 LuaJIT 的区别</h3><p>Lua 非常高效，它运行得比许多其它脚本(如 Perl、Python、Ruby)都快，这点在第三方的独立测评中得到了证实。尽管如此，仍然会有人不满足，他们总觉得还不够快。LuaJIT 就是一个为了再榨出一些速度的尝试，它利用即时编译（Just-in Time）技术把 Lua 代码编译成本地机器码后交由 CPU 直接执行。  </p>
<p>LuaJIT 2 的测评报告表明，在数值运算、循环与函数调用、协程切换、字符串操作等许多方面它的加速效果都很显著。  </p>
<p>凭借着 FFI 特性，LuaJIT 2 在那些需要频繁地调用外部 C&#x2F;C++ 代码的场景，也要比标准 Lua 解释器快很多。  </p>
<p>目前 LuaJIT 2 已经支持包括 i386、x86_64、ARM、PowerPC 以及 MIPS 等多种不同的体系结构。</p>
<p>LuaJIT 是采用 C 和汇编语言编写的 Lua 解释器与即时编译器。LuaJIT 被设计成全兼容标准的 Lua 5.1 语言，同时可选地支持 Lua 5.2 和 Lua 5.3 中的一些不破坏向后兼容性的有用特性。因此，标准 Lua 语言的代码可以不加修改地运行在 LuaJIT 之上。  </p>
<p>LuaJIT 和标准 Lua 解释器的一大区别是，LuaJIT 的执行速度，即使是其汇编编写的 Lua 解释器，也要比标准 Lua 5.1 解释器快很多，可以说是一个高效的 Lua 实现。另一个区别是，LuaJIT 支持比标准 Lua 5.1 语言更多的基本原语和特性，因此功能上也要更加强大。</p>
<p>LuaJIT 官网链接：<a target="_blank" rel="noopener" href="http://luajit.org/">http://luajit.org</a></p>
<h3 id="OpenResty-与-Lua、LuaJIT"><a href="#OpenResty-与-Lua、LuaJIT" class="headerlink" title="OpenResty 与 Lua、LuaJIT"></a>OpenResty 与 Lua、LuaJIT</h3><p>自从 OpenResty 1.5.8.1 版本之后，默认捆绑的 Lua 解释器就被替换成了 LuaJIT，而不再是标准 Lua。也就是，我们安装了OpenResty也会包含Lua解释器。</p>
<p>OpenResty 官网链接：<a target="_blank" rel="noopener" href="http://openresty.org/cn/">http://openresty.org/cn/</a></p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>我们创建一个 HelloWorld.lua 文件，代码如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lua HelloWorld.lua</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>Hello World!</p>
<p>Lua也提供了交互式编程。打开命令行输入<code>lua</code>就会进入交互式编程模式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ lua</span><br><span class="line">Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio</span><br><span class="line">&gt; print(&quot;Hello World!&quot;)</span><br><span class="line">Hello World!</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>两个减号是单行注释:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>多行注释:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> --]]</span></span><br></pre></td></tr></table></figure>

<h3 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h3><p>Lua标示符以一个字母 A 到 Z 或 a 到 z 或下划线<code>_</code>开头后加上0个或多个字母，下划线，数字（0到9）。<br>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。<br>Lua 不允许使用特殊字符如 <code>@</code>, <code>$</code>, 和 <code>%</code> 来定义标示符。<br>Lua区分大小写。</p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and	break	do	else</span><br><span class="line">elseif	end	false	for</span><br><span class="line">function	if	in	local</span><br><span class="line">nil	not	or	repeat</span><br><span class="line">return	then	true	until</span><br><span class="line">while		</span><br></pre></td></tr></table></figure>

<p>一般约定，以下划线开头连接一串大写字母的名字（比如 <code>_VERSION</code> ）被保留用于 Lua 内部全局变量。  </p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量在使用前，必须在代码中进行声明，即创建该变量。  </p>
<p>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;yjc&quot;</span></span><br><span class="line">year = <span class="number">2018</span></span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line">score = <span class="number">98.01</span></span><br></pre></td></tr></table></figure>

<p>变量的默认值均为 <code>nil</code>。访问一个没有初始化的全局变量不会出错，只不过返回结果是：nil。当然如果你想删除一个全局变量，只需要将变量赋值为nil即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">98.01</span></span><br><span class="line">score = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>Lua 变量作用域:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>	<span class="comment">--全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">10</span> 	<span class="comment">--局部变量</span></span><br></pre></td></tr></table></figure>

<p>Lua 中的局部变量要用<code>local</code>关键字来显式定义，不使用 local 显式定义的变量就是全局变量。就算在<code>if</code>等语句块中，只要没使用<code>local</code>关键字来显式定义，也是全局变量，这一点和别的语言不同。  </p>
<p>实际编程中尽量使用局部变量。</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>1、<a target="_blank" rel="noopener" href="http://notebook.kulchenko.com/programming/lua-good-different-bad-and-ugly-parts">http://notebook.kulchenko.com/programming/lua-good-different-bad-and-ugly-parts</a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><hr>
<p>Lua中有8个基本类型分别为：nil、boolean、number、string、table、function、userdata、thread。  </p>
<p>函数 <code>type</code> 能够返回一个值或一个变量所属的类型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;hello world&quot;</span>)) <span class="comment">--&gt;output:string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>)) <span class="comment">--&gt;output:function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>)) <span class="comment">--&gt;output:boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">360.0</span>)) <span class="comment">--&gt;output:number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>)) <span class="comment">--&gt;output:nil</span></span><br></pre></td></tr></table></figure>

<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>只有值<code>nil</code>属于该类，表示一个无效值（在条件表达式中相当于false）。一个变量在第一次赋值前的默认值是 <code>nil</code>，将<br>nil 赋予给一个全局变量就等同于删除它。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> num</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment">--&gt;output:nil</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment">--&gt;output:100</span></span><br></pre></td></tr></table></figure>

<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>boolean 类型只有两个可选值：<code>true</code>和<code>false</code>，Lua 把 <code>false</code> 和 <code>nil</code> 看作是”假”，其他的都为”真”，比如 0 和空字符串就是”真”，这和C、PHP等语言不一样。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> c = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>) <span class="comment">--&gt;output:a</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;not a&quot;</span>) <span class="comment">--这个没有执行</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>) <span class="comment">--&gt;output:b</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;not b&quot;</span>) <span class="comment">--这个没有执行</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>) <span class="comment">--这个没有执行</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;not c&quot;</span>) <span class="comment">--&gt;output:not c</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">not c</span><br></pre></td></tr></table></figure>

<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>Lua 默认只有一种 number 类型: double（双精度）类型，以下几种写法都被看作是 <code>number</code> 类型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2e+1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2e-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">7.8263692594256e-06</span>))</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>字符串由一对双引号或单引号来表示:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">&quot;this is string1\n&quot;</span></span><br><span class="line">string2 = <span class="string">&#x27;this is string2\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(string1)</span><br><span class="line"><span class="built_in">print</span>(string2)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this is string1</span><br><span class="line"></span><br><span class="line">this is string2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出单引号里面转义字符也生效。说明Lua不区分单引号、双引号。    </p>
<p>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。我们把两个正的方括号（即<code>[[</code>）间插入 n 个等号定义为第 n 级正长括号:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string3 = <span class="string">[[this is string3\n]]</span> <span class="comment">-- 0 级正的长括号</span></span><br><span class="line">string4 = <span class="string">[=[this is string4\n]=]</span> <span class="comment">-- 1 级正的长括号</span></span><br><span class="line">string5 = <span class="string">[==[this is string5\n]==]</span> <span class="comment">-- 2 级正的长括号</span></span><br><span class="line">string6 = <span class="string">[====[ this is string6\n[===[]===] ]====]</span> <span class="comment">-- 4 级正的长括号，可以包含除了本级别的反长括号外的所有内容</span></span><br><span class="line"><span class="built_in">print</span>(string3)</span><br><span class="line"><span class="built_in">print</span>(string4)</span><br><span class="line"><span class="built_in">print</span>(string5)</span><br><span class="line"><span class="built_in">print</span>(string6)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this is string3\n</span><br><span class="line">this is string4\n</span><br><span class="line">this is string5\n</span><br><span class="line"> this is string6\n[===[]===]</span><br></pre></td></tr></table></figure>

<p>注意：由方括号包含的字符串，整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。    </p>
<p>另外，需要注意的就是：Lua的字符串是不可改变的值，不能像在 c 语言中那样直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。Lua 也不能通过下标来访问字符串的某个字符。  </p>
<p>字符串使用<code>..</code>拼接：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string7 = string3..string4</span><br><span class="line"><span class="built_in">print</span>(string7)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is string3\nthis is string4\n</span><br></pre></td></tr></table></figure>

<p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span> + 6)</span><br><span class="line">8.0</span><br></pre></td></tr></table></figure>

<p>使用 <code>#</code> 来计算字符串的长度，放在字符串前面，如下实例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> string8 = <span class="string">&quot;this is string8&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#string8) <span class="comment">-- 输出：15</span></span><br></pre></td></tr></table></figure>

<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是<code>string</code>或者<code>number</code>类型，但也可以是除 <code>nil</code> 以外的任意类型的值。  </p>
<p>PHP程序员对此会很熟悉，因为PHP里的数组(<code>array</code>)和Table非常类似。示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tmp = &#123;</span><br><span class="line">	name = <span class="string">&quot;lua&quot;</span>,</span><br><span class="line">	<span class="comment">-- &quot;name2&quot; = &quot;lua2&quot;, -- 错误的表示</span></span><br><span class="line">	[<span class="string">&quot;name3&quot;</span>] = <span class="string">&quot;lua&quot;</span>,</span><br><span class="line">	year = <span class="number">2018</span>,</span><br><span class="line">	<span class="built_in">pi</span> = <span class="number">3.14159</span>,</span><br><span class="line">	lang = &#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;lua&quot;</span>&#125;,</span><br><span class="line">	<span class="number">100</span>,  <span class="comment">-- 相当于[1] = 100，此时索引为数字。lua里数字索引是从1开始的，不是0</span></span><br><span class="line">	<span class="comment">-- 10 = 11, -- 错误的表示</span></span><br><span class="line">	[<span class="number">10</span>] = <span class="number">11</span>, <span class="comment">-- 相当于[10] = 11，此时索引为数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tmp.name)  <span class="comment">-- 等同于 print(tmp[&quot;name&quot;])</span></span><br><span class="line"><span class="built_in">print</span>(tmp[<span class="string">&quot;name3&quot;</span>])  <span class="comment">-- 等同于 print(tmp.name3)</span></span><br><span class="line"><span class="built_in">print</span>(tmp.year)</span><br><span class="line"><span class="built_in">print</span>(tmp.<span class="built_in">pi</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp.lang[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tmp[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tmp[<span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line">lua</span><br><span class="line">2018</span><br><span class="line">3.14159</span><br><span class="line">c</span><br><span class="line">100</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>在 Lua 里表的默认初始索引一般以 1 开始，而不是0，这点需要注意。   </p>
<p>也可以先创建一个空表，再添加数据：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a.key = <span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure>


<p>在内部实现上，table 通常实现为一个哈希表、一个数组、或者两者的混合。具体的实现为何种形式，动态依赖于具体的 table 的键分布特点。</p>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>在 Lua 中，<code>函数</code> 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxNumber</span><span class="params">(a, b)</span></span></span><br><span class="line">	<span class="keyword">if</span> a &gt; b <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> testFunc = maxNumber</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(testFunc(<span class="number">10</span>,<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100  </span><br></pre></td></tr></table></figure>

<p>有名函数的定义本质上是匿名函数对变量的赋值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="userdata"><a href="#userdata" class="headerlink" title="userdata"></a>userdata</h2><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p>
<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。<br>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><hr>
<p>Lua支持下列主要的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
</ul>
<p>还支持<code>..</code>、<code>#</code>特殊运算符。其中赋值运算符仅支持<code>=</code>，不支持C语言的<code>+=</code>、<code>++</code>等运算符。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 加法</span><br><span class="line">- 减法或者负号</span><br><span class="line">* 乘法</span><br><span class="line">/ 除法</span><br><span class="line">^ 指数</span><br><span class="line">% 取模</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + <span class="number">2</span>) <span class="comment">--&gt;打印 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> / <span class="number">10</span>) <span class="comment">--&gt;打印 0.5。 这是Lua不同于c语言的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5.0</span> / <span class="number">10</span>) <span class="comment">--&gt;打印 0.5。 浮点数相除的结果是浮点数</span></span><br><span class="line"><span class="comment">-- print(10 / 0) --&gt;注意除数不能为0，计算的结果会出错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> ^ <span class="number">10</span>) <span class="comment">--&gt;打印 1024。 求2的10次方</span></span><br></pre></td></tr></table></figure>

<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt; 小于</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt;= 小于等于</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">== 等于</span><br><span class="line">~= 不等于</span><br></pre></td></tr></table></figure>

<p>注意：Lua 语言中“不等于”运算符的写法为：<code>~=</code>。  </p>
<p>由于 Lua 字符串总是会被“内化”，即相同内容的字符串只会被保存一份，因此 Lua 字符串之间的相等性比较可以简化为其内部存储地址的比较。其它语言一般需要逐个字节（或按<br>若干个连续字节）进行比较。  </p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and 逻辑与</span><br><span class="line">or 逻辑或</span><br><span class="line">not 逻辑非</span><br></pre></td></tr></table></figure>

<p>Lua 中的 <code>and</code> 和 <code>or</code> 是不同于 c 语言的。在 c 语言中，<code>and</code> 和 <code>or</code> 只得到两个值 1 和 0，其中 1 表示真，0 表示假。而 Lua 中 <code>and</code> 的执行过程是这样的：</p>
<ul>
<li>a and b 如果 a 为 nil，则返回 a，否则返回 b;</li>
<li>a or b 如果 a 为 nil，则返回 b，否则返回 a。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">and</span> a)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">or</span> a)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br><span class="line">nil</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">= 简单的赋值运算符，把右边操作数的值赋给左边操作数</span><br></pre></td></tr></table></figure>

<h2 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">..	连接两个字符串</span><br><span class="line">#	一元运算符，返回字符串或表的长度。</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>..<span class="string">&quot; world&quot;</span>) <span class="comment">-- 输出：hello world</span></span><br><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;hello&quot;</span>) <span class="comment">-- 输出：5</span></span><br></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><hr>
<p>Lua 语言提供的控制结构有 <code>if-else</code>，<code>while</code>，<code>repeat</code>，<code>for</code>，并提供 <code>break</code>、<code>return</code> 关键字来满足更丰富的需求。不支持<code>switch</code>、<code>continue</code>。 </p>
<p>Lua 提供的控制语句部分特征类似Shell和Python：</p>
<ul>
<li>语句都以<code>end</code>结束</li>
<li><code>if</code>后面都有<code>then</code></li>
<li>没有花括号<code>&#123;&#125;</code></li>
<li>循环结构<code>while</code>、<code>for</code>表达式后面都有关键字<code>do</code>; python里是用的<code>:</code></li>
</ul>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>单个 if 分支 型:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>两个分支 if-else 型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">11</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>多个分支 if-elseif-else 型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">11</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">elseif</span> a &lt; b <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>与 C 语言的不同之处是 <code>else</code> 与 <code>if</code> 是连在一起的，若将 <code>else</code> 与 <code>if</code> 写成 <code>else if</code> 则相当于在<code>else</code> 里嵌套另一个 <code>if</code>语句。</p>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>Lua 跟其他常见语言一样，提供了 <code>while</code> 控制结构，语法上也没有什么特别的。但是没有提供 <code>do-while</code> 型的控制结构，但是提供了功能相当的 <code>repeat</code>。 </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">100</span> <span class="keyword">do</span></span><br><span class="line">	sum = sum + i</span><br><span class="line">	i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum) <span class="comment">-- 5050</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Lua 并没有像许多其他语言那样提供类似 <code>continue</code> 这样的控制语句用来跳过当前循环。</p>
</blockquote>
<p>再看看 <code>repeat</code> 的用法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">	sum = sum + i</span><br><span class="line">	i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">until</span> i&gt;<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(sum) <span class="comment">-- 5050</span></span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>for有两种结构：数字 for（numeric for） 和范型 for（generic for）。</p>
<p>数字 for 类似C语言的用法；范型 for 类似Python里的<code>for...in</code>用法。</p>
<h3 id="for-数字型"><a href="#for-数字型" class="headerlink" title="for 数字型"></a>for 数字型</h3><p>数字型 for 的语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var = begin, finish, step <span class="keyword">do</span></span><br><span class="line">	<span class="comment">--body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>需要关注以下几点： </p>
<ul>
<li><code>var</code> 从 <code>begin</code> 变化到 <code>finish</code>，每次变化都以 <code>step</code> 作为步长递增 <code>var</code></li>
<li><code>begin</code>、<code>finish</code>、<code>step</code> 三个表达式只会在循环开始时执行一次 </li>
<li>第三个表达式 <code>step</code>是可选的，默认为 <code>1</code></li>
<li>控制变量 <code>var</code> 的作用域仅在 <code>for</code> 循环内，需要在外面控制，则需将值赋给一个新的变量 </li>
<li>循环过程中不要改变控制变量的值，那样会带来不可预知的影响</li>
</ul>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span>,<span class="number">100</span>,<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">	sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum) <span class="comment">-- 5050</span></span><br></pre></td></tr></table></figure>

<h3 id="for-泛型"><a href="#for-泛型" class="headerlink" title="for 泛型"></a>for 泛型</h3><p>Lua 编程语言中泛型for循环语法格式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印数组a的所有值  </span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">print</span>(v) </span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure>

<p><code>i</code>是数组索引值，<code>v</code>是对应索引的数组元素值。<code>ipairs</code>是<code>Lua</code>提供的一个迭代器函数，用来迭代数组。</p>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;</span><br><span class="line">	<span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(days) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1       Monday</span><br><span class="line">2       Tuesday</span><br><span class="line">3       Wednesday</span><br><span class="line">4       Thursday</span><br><span class="line">5       Friday</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ipairs以及pairs 的不同:<br>pairs可以遍历表中所有的key，并且除了迭代器本身以及遍历表本身还可以返回nil; 但是ipairs则不能返回nil，只能返回数字0，如果值遇到nil则直接跳出循环退出。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tabFiles = &#123;  </span><br><span class="line">	[<span class="number">1</span>] = <span class="string">&quot;test1&quot;</span>,  </span><br><span class="line">	[<span class="number">6</span>] = <span class="string">&quot;test2&quot;</span>,  </span><br><span class="line">	[<span class="number">4</span>] = <span class="string">&quot;test3&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(tabFiles) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1       test1</span><br></pre></td></tr></table></figure>

<p><code>ipairs</code>遍历时，当key&#x3D;2时候value就是nil，所以直接跳出循环。    </p>
<p>如果换成<code>pairs</code>，则全部输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1       test1</span><br><span class="line">6       test2</span><br><span class="line">4       test3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得一提的是，在 LuaJIT 2.1 中， <code>ipairs()</code> 内建函数是可以被 <code>JIT</code> 编译的，而 <code>pairs()</code> 则只能被解释执行。</p>
</blockquote>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>语句 <code>break</code> 用来终止 <code>while</code> 、 repeat 和 for 三种循环的执行，并跳出当前循环体， 继续执行当前循环之后的语句。</p>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p><code>return</code> 主要用于从函数中返回结果，或者用于简单的结束一个函数的执行。  </p>
<p>需要注意的是： return 只能写在语句块的最后，一旦执行了 return 语句，该语句之后的所有语句都不会再执行。  </p>
<p>若要写在函数中间，则只能写在一个显式的语句块内，否则会报错：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">(x, y)</span></span></span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">	<span class="comment">-- print(x+y)</span></span><br><span class="line">	<span class="comment">-- 后面的print如果不注释，会报错</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span><span class="params">(x, y)</span></span></span><br><span class="line">	<span class="keyword">if</span> x &gt; y <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> y</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>) <span class="comment">-- 此处的print不注释不会报错，因为return只出现在前面显式的语句块</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span><span class="params">(x, y)</span></span></span><br><span class="line">	<span class="built_in">print</span>(x+y)</span><br><span class="line">	<span class="keyword">do</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">print</span>(x) <span class="comment">-- 此处的print不注释不会报错，因为return由do...end语句块包含。这一行语句永远不会执行到</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test1(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">test2(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">test3(<span class="number">10</span>,<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>所以，有时候为了调试方便，我们可以想在某个函数的中间提前 return ，以进行控制流的短路，此时我们可以将 return 放在一个 <code>do...end</code> 代码块中。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><hr>
<p>在 Lua 中，函数 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数定义格式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span> <span class="params">(arc)</span></span> <span class="comment">-- arc 表示参数列表，函数的参数列表可以为空</span></span><br><span class="line">	<span class="comment">-- body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>支持使用<code>local</code>定义为局部作用域的函数。  </p>
<blockquote>
<p>由于函数定义本质上就是变量赋值，而变量的定义总是应放置在变量使用之前，所以函数的定义也需要放置在函数调用之前。  </p>
</blockquote>
<p>由于函数定义等价于变量赋值，我们也可以把函数名替换为某个 Lua 表的某个字段，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.bar</span><span class="params">(a, b, c)</span></span></span><br><span class="line">	<span class="comment">-- body ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>对于此种形式的函数定义，不能再使用 <code>local</code> 修饰符了，因为不存在定义新的局部变量了。  </p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>支持固定参数和变长参数。固定参数很好理解，变长参数则是使用<code>...</code>定义的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span> <span class="params">(...)</span></span></span><br><span class="line">	<span class="keyword">local</span> args = &#123;...&#125; <span class="keyword">or</span> &#123;&#125; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>注意：在调用函数的时候，如果实参和形参个数不一样的时候：</p>
<ul>
<li>实参缺少，则使用nil代替</li>
<li>实参大于形参，则忽略</li>
</ul>
<blockquote>
<p>LuaJIT 2 尚不能 JIT 编译这种变长参数的用法，只能解释执行。</p>
</blockquote>
<p>Lua函数的参数大部分是按值传递的。值传递就是调用函数时，实参把它的值通过赋值运算传递给形参，然后形参的改变和实参就没有关系了。  </p>
<p>当函数参数是 <code>table</code> 类型时，传递进来的是实际参数的引用，此时在函数内部对该 table 所做的修改，会直接对调用者所传递的实际参数生效。</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>Lua可以返回多个值，这点和Python、Go类似，不同于C、PHP等语言。返回多个值时，值之间用“,”隔开。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(a, b)</span></span> </span><br><span class="line">	<span class="keyword">return</span> b, a <span class="comment">-- 按相反顺序返回变量的值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(swap(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2	1</span><br></pre></td></tr></table></figure>

<p>注意：在调用函数的时候，如果返回值的个数和接收返回值的变量的个数不一致时：</p>
<ul>
<li>返回值缺少，则使用nil代替</li>
<li>返回值个数大于接收变量的个数，则忽略</li>
</ul>
<p>当一个方法返回多个值时，有些返回值有时候用不到，要是声明很多变量来一一接收，显然不太合适 。Lua 提供了一个虚变量(dummy variable)，以单个下划线（“_”） 来命名，用它来丢弃不需要的数值，仅仅起到占位的作用。这点和Go用法一致。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">test_var</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> x,_,y = test_var()</span><br><span class="line"><span class="built_in">print</span>(x,y) <span class="comment">-- 1	3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数动态调用"><a href="#函数动态调用" class="headerlink" title="函数动态调用"></a>函数动态调用</h2><p>函数动态调用是指：调用回调函数，并把一个数组参数作为回调函数的参数。  </p>
<p>主要用到了<code>unpack</code>函数和可变参数。  </p>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_action</span><span class="params">(func, ...)</span></span></span><br><span class="line">	<span class="keyword">local</span> args = &#123;...&#125; <span class="keyword">or</span> &#123;&#125; <span class="comment">-- 防止为nil</span></span><br><span class="line">	func(<span class="built_in">unpack</span>(args, <span class="number">1</span>, <span class="built_in">table</span>.<span class="built_in">maxn</span>(args))) <span class="comment">-- 如果实参中确定没有nil空洞（nil值被夹在非空值之间），可以只写第一个参数 </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span></span></span><br><span class="line">	<span class="built_in">print</span>(x+y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add2</span><span class="params">(x, y, z)</span></span></span><br><span class="line">	<span class="built_in">print</span>(x+y+z)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">do_action(add, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">do_action(add2, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>unpack</code> 内建函数还不能为 LuaJIT 所 JIT 编译，因此这种用法总是会被解释执行。</p>
</blockquote>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><hr>
<h2 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h2><p>从Lua5.1开始，Lua添加了对模块和包的支持。  </p>
<p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。   </p>
<p>示例：  </p>
<p>mymodule.lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">_M.VERSION = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">_M.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;get&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>

<p>使用<code>require</code>即可引入模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;mymodule&quot;</span></span><br><span class="line"><span class="built_in">print</span>(m.VERSION)</span><br><span class="line"><span class="built_in">print</span>(m.getName())</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br><span class="line">get</span><br></pre></td></tr></table></figure>

<h2 id="点号与冒号操作符的区别"><a href="#点号与冒号操作符的区别" class="headerlink" title="点号与冒号操作符的区别"></a>点号与冒号操作符的区别</h2><p>看下面示例代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> str = <span class="string">&quot;abcde&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;case 1:&quot;</span>, str:<span class="built_in">sub</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;case 2:&quot;</span>, str.<span class="built_in">sub</span>(str, <span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">case 1: ab</span><br><span class="line">case 2: ab</span><br></pre></td></tr></table></figure>

<p>冒号操作会带入一个 <code>self</code> 参数，用来代表 <code>自己</code> 。而点号操作，只是内容的展开，需要手动传入<code>self</code> 参数。  </p>
<p>在函数定义时，使用冒号将默认接收一个 <code>self</code> 参数，而使用点号则需要显式传入 <code>self</code> 参数。  </p>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mytable = &#123;&#125;</span><br><span class="line">mytable.func1 = <span class="function"><span class="keyword">function</span><span class="params">(self, name)</span></span></span><br><span class="line">	<span class="built_in">self</span>.name = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mytable:func2 = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span></span><br><span class="line">	<span class="built_in">self</span>.name = name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>func1</code>和<code>func2</code>是等价的。</p>
<h1 id="常用库介绍"><a href="#常用库介绍" class="headerlink" title="常用库介绍"></a>常用库介绍</h1><hr>
<h2 id="String-库"><a href="#String-库" class="headerlink" title="String 库"></a>String 库</h2><ul>
<li><code>..</code> 链接两个字符串</li>
<li><code>string.upper(argument)</code> 字符串全部转为大写字母。</li>
<li><code>string.lower(argument)</code> 字符串全部转为小写字母。</li>
<li><code>string.len(arg)</code> 计算字符串长度</li>
<li><code>string.reverse(arg)</code> 字符串反转</li>
<li><code>string.format(...)</code> 返回一个类似printf的格式化字符串</li>
<li><code>string.byte(s [, i [, j ]])</code> 转换字符为整数值(可以指定某个字符，默认第一个字符)</li>
<li><code>string.char(arg)</code> 将整型数字转成字符并连接</li>
<li><code>string.rep(string, n)</code> 返回字符串string的n个拷贝</li>
<li><code>string.gsub(mainString, findString, replaceString, num)</code><br>在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）</li>
<li><code>string.find (str, substr, [init, [end]])</code><br>在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil。</li>
<li><code>string.gmatch(str, pattern)</code><br>返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。</li>
<li><code>string.match(str, pattern, init)</code><br>寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。</li>
</ul>
<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p><code>string.format()</code>类似c里的<code>printf()</code>。示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;name %s, age %s&quot;</span>, <span class="string">&quot;yjc&quot;</span>, <span class="number">20</span>)) <span class="comment">-- name yjc, age 20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%.4f&quot;</span>,<span class="number">1</span>/<span class="number">3</span>)) <span class="comment">-- 0.3333</span></span><br></pre></td></tr></table></figure>

<p>格式字符串可能包含以下的转义码:</p>
<ul>
<li><code>%c</code> - 接受一个数字, 并将其转化为ASCII码表中对应的字符</li>
<li><code>%d</code>, <code>%i</code> - 接受一个数字并将其转化为有符号的整数格式</li>
<li><code>%o</code> - 接受一个数字并将其转化为八进制数格式</li>
<li><code>%u</code> - 接受一个数字并将其转化为无符号整数格式</li>
<li><code>%x</code> - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</li>
<li><code>%X</code> - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</li>
<li><code>%e</code> - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e</li>
<li><code>%E</code> - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E</li>
<li><code>%f</code> - 接受一个数字并将其转化为浮点数格式</li>
<li><code>%g(%G)</code> - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式</li>
<li><code>%q</code> - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</li>
<li><code>%s</code> - 接受一个字符串并按照给定的参数格式化该字符串</li>
</ul>
<p>为进一步细化格式, 可以在<code>%</code>号后添加参数. 参数将以如下的顺序读入:</p>
<ul>
<li>符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.</li>
<li>占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</li>
<li>对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</li>
<li>宽度数值</li>
<li>小数位数&#x2F;字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如<code>%6.3f</code>)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如<code>%5.3s</code>)则设定该字符串只显示前n位.</li>
</ul>
<blockquote>
<p>注：<code>string.match()</code>、<code>string.gmatch()</code> 目前并不能被 JIT 编译，OpenResty 里应尽量使用 <code>ngx_lua</code> 模块提供的 <code>ngx.re.match</code> 等API。</p>
</blockquote>
<h2 id="Table-库"><a href="#Table-库" class="headerlink" title="Table 库"></a>Table 库</h2><ul>
<li><code>table.concat (table [, sep [, start [, end]]])</code><br>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</li>
<li><code>table.insert (table, [pos,] value)</code><br>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</li>
<li><code>table.maxn (table)</code><br>指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(<strong>Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现</strong>)</li>
<li><code>table.remove (table [, pos])</code><br>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</li>
<li><code>table.sort (table [, comp])</code><br>对给定的table进行升序排序。</li>
</ul>
<h2 id="日期时间库"><a href="#日期时间库" class="headerlink" title="日期时间库"></a>日期时间库</h2><ul>
<li><code>os.time ([table])</code> 如果不使用参数 table 调用 time 函数，它会返回当前的时间和日期（它表示从某一时刻到现在的秒数）。如果用 table 参数，它会返回一个数字，表示该 table 中 所描述的日期和时间（它表示从某一时刻到 table 中描述日期和时间的秒数）。</li>
<li><code>os.difftime (t2, t1)</code> 返回 t1 到 t2 的时间差，单位为秒。</li>
<li><code>os.date ([format [, time]])</code> 把一个表示日期和时间的数值，转换成更高级的表现形式。其第一个参数 format 是一个格式化字符串，描述了要返回的时间形式。第二个参数 time 就是日期和时间的数字表示，缺省时默认为当前的时间。</li>
</ul>
<blockquote>
<p>如果使用OpenResty，不建议使用Lua的标准时间函数，因为这些函数通常会引发不止一个昂贵的系统调用，同时无法为 LuaJIT JIT 编译，对性能造成较大影响。推荐使用 ngx_lua 模块提供的带缓存的时间接口，如 <code>ngx.today</code>, <code>ngx.time</code>, <code>ngx.utctime</code>, <code>ngx.localtime</code>, <code>ngx.now</code>, <code>ngx.http_time</code>，以及 <code>ngx.cookie_time</code> 等。</p>
</blockquote>
<h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><p>常用数学函数：  </p>
<ul>
<li><code>math.rad(x)</code>  角度x转换成弧度</li>
<li><code>math.deg(x)</code>  弧度x转换成角度</li>
<li><code>math.max(x, ...)</code>  返回参数中值最大的那个数，参数必须是number型</li>
<li><code>math.min(x, ...)</code>  返回参数中值最小的那个数，参数必须是number型</li>
<li><code>math.random ([m [, n]])</code>  不传入参数时，返回 一个在区间[0,1)内均匀分布的伪随机实数；只使用一个整数参数m时，返回一个在区间[1, m]内均匀分布的伪随机整数；使用两个整数参数时，返回一个在区间[m, n]内均匀分布的伪随机整数</li>
<li><code>math.randomseed (x)</code>  为伪随机数生成器设置一个种子x，相同的种子将会生成相同的数字序列</li>
<li><code>math.abs(x)</code>  返回x的绝对值</li>
<li><code>math.fmod(x, y)</code>  返回 x对y取余数</li>
<li><code>math.pow(x, y)</code>  返回x的y次方</li>
<li><code>math.sqrt(x)</code>  返回x的算术平方根</li>
<li><code>math.exp(x)</code>  返回自然数e的x次方</li>
<li><code>math.log(x)</code>  返回x的自然对数</li>
<li><code>math.log10(x)</code>  返回以10为底，x的对数</li>
<li><code>math.floor(x)</code>  返回最大且不大于x的整数</li>
<li><code>math.ceil(x)</code>  返回最小且不小于x的整数</li>
<li><code>math.pi</code>	圆周率</li>
<li><code>math.sin(x)</code>  求弧度x的正弦值</li>
<li><code>math.cos(x)</code>  求弧度x的余弦值</li>
<li><code>math.tan(x)</code>  求弧度x的正切值</li>
<li><code>math.asin(x)</code>  求x的反正弦值</li>
<li><code>math.acos(x)</code>  求x的反余弦值</li>
<li><code>math.atan(x)</code>  求x的反正切值</li>
</ul>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- src/test_math.lua</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">pi</span>) <span class="comment">-- 3.1415926535898</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">3</span>))  <span class="comment">-- 8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3.6</span>, <span class="number">9.1</span>))     <span class="comment">--  9.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">floor</span>(<span class="number">3.14159</span>))  <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">ceil</span>(<span class="number">7.9988</span>))    <span class="comment">-- 8</span></span><br></pre></td></tr></table></figure>

<p>注意：使用 <code>math.random()</code> 函数获得伪随机数时，如果不使用 <code>math.randomseed()</code> 设置伪随机数生成种子或者设置相同的伪随机数生成种子，那么得得到的伪随机数序列是一样的。示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- math.randomseed(os.time())  -- 设置随机种子</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>()) <span class="comment">-- 0.79420629243124</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">10</span>)) <span class="comment">-- 7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">10</span>,<span class="number">20</span>)) <span class="comment">-- 16</span></span><br></pre></td></tr></table></figure>

<p>上面的例子里同一机器运行多次的结果是一样的，只有设置了随机的伪随机数生成种子，才能保证每次生成的随机数是不相同的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、OpenResty最佳实践<br><a target="_blank" rel="noopener" href="https://moonbingbing.gitbooks.io/openresty-best-practices/">https://moonbingbing.gitbooks.io/openresty-best-practices/</a><br>2、Lua 5.3 参考手册 - 目录<br><a target="_blank" rel="noopener" href="http://www.runoob.com/manual/lua53doc/contents.html">http://www.runoob.com/manual/lua53doc/contents.html</a><br>3、Lua 字符串 | 菜鸟教程<br><a target="_blank" rel="noopener" href="http://www.runoob.com/lua/lua-strings.html">http://www.runoob.com/lua/lua-strings.html</a>  </p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><hr>
<p>Lua I&#x2F;O 库用于读取和处理文件。分为简单模式、完全模式。</p>
<ul>
<li>简单模式（simple model）<br>拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。</li>
<li>完全模式（complete model）<br>使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法。</li>
</ul>
<p>对文件进行简单的读写操作时可以使用简单模式，但是对文件进行一些高级的操作简单模式则处理不了了。</p>
<h2 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h2><p>简单模式由<code>io</code>模块提供，主要有：</p>
<ul>
<li><code>io.open(filename [, mode])</code>: 以mode模式打开一个文件</li>
<li><code>io.input(file)</code>: 设置默认输入文件为file</li>
<li><code>io.output(file)</code>: 设置默认输出文件为file</li>
<li><code>io.write(content)</code>: 在文件最后一行添加content内容</li>
<li><code>io.read()</code>:  读取文件的一行。<br>参数可以是下列中的一个：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;*n&quot;</span>	读取一个数字并返回它。例：file.<span class="built_in">read</span>(<span class="string">&quot;*n&quot;</span>)</span><br><span class="line"><span class="string">&quot;*a&quot;</span>	从当前位置读取整个文件。例：file.<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>)</span><br><span class="line"><span class="string">&quot;*l&quot;</span>   （默认）读取下一行，在文件尾 (EOF) 处返回 <span class="literal">nil</span>。例：file.<span class="built_in">read</span>(<span class="string">&quot;*l&quot;</span>)</span><br><span class="line">number	返回一个指定字符个数的字符串，或在 EOF 时返回 <span class="literal">nil</span>。例：file.<span class="built_in">read</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>io.close(file)</code>: 关闭打开的文件file</li>
<li><code>io.tmpfile()</code>: 返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除</li>
<li><code>io.type(file)</code>: 检测obj是否一个可用的文件句柄</li>
<li><code>io.flush()</code>: 向文件写入缓冲中的所有数据</li>
<li><code>io.lines(optional file name)</code>: 返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件</li>
</ul>
<p>mode模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</td>
</tr>
<tr>
<td>r+</td>
<td>以可读写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td>a+</td>
<td>与a类似，但此文件可读可写</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式，如果文件是二进制文件，可以加上</td>
</tr>
<tr>
<td>b+</td>
<td>二进制模式，表示对文件既可以读也可以写</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- write</span></span><br><span class="line"><span class="comment">-- src/file_io_write.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">output</span>(file) <span class="comment">-- 设置默认输出文件</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;hello lua!\nhahah&quot;</span>) <span class="comment">-- 把内容写到文件</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">close</span>(file)</span><br></pre></td></tr></table></figure>

<p>运行后查看生成的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test_file.txt</span><br><span class="line">hello lua!</span><br><span class="line">nhahah</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- read</span></span><br><span class="line"><span class="comment">-- src/file_io_read.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(file) <span class="comment">-- 设置默认输入文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- while true do</span></span><br><span class="line"><span class="comment">--     line = io.read()</span></span><br><span class="line"><span class="comment">--     if line == nil then</span></span><br><span class="line"><span class="comment">--         break;</span></span><br><span class="line"><span class="comment">--     end</span></span><br><span class="line"><span class="comment">--     print(line)</span></span><br><span class="line"><span class="comment">-- end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">close</span>(file)</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ luajit file_io_read.lua</span><br><span class="line">hello lua!</span><br><span class="line">hahah</span><br></pre></td></tr></table></figure>

<h2 id="完全模式"><a href="#完全模式" class="headerlink" title="完全模式"></a>完全模式</h2><p>简单模式由<code>file</code>模块提供，主要有：</p>
<ul>
<li><code>file:write(content)</code>: 在文件最后一行添加content内容</li>
<li><code>file:read()</code>:  读取文件的一行</li>
<li><code>file:close()</code>: 关闭打开的文件</li>
<li><code>file:seek(optional where, optional offset)</code>: 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。</li>
</ul>
<p>参数 where 值可以是:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;set&quot;</span>: 从文件头开始</span><br><span class="line"><span class="string">&quot;cur&quot;</span>: 从当前位置开始[默认]</span><br><span class="line"><span class="string">&quot;end&quot;</span>: 从文件尾开始</span><br><span class="line">offset:默认为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>file:flush()</code>: 向文件写入缓冲中的所有数据</li>
</ul>
<p>其中 <code>file</code> 为 <code>io.open()</code> 返回的文件句柄。</p>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- read</span></span><br><span class="line"><span class="comment">-- src/file_read.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file:seek(<span class="string">&quot;end&quot;</span>, <span class="number">-5</span>) <span class="comment">-- 定位到文件倒数第 5 个位置</span></span><br><span class="line"><span class="built_in">print</span>(file:<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>)) <span class="comment">-- 从当前位置读取整个文件</span></span><br><span class="line"></span><br><span class="line">file:<span class="built_in">close</span>()  <span class="comment">-- 关闭打开的文件</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ luajit src/file_read.lua</span><br><span class="line">hahah</span><br></pre></td></tr></table></figure>

<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>1、文件操作 · OpenResty最佳实践<br><a target="_blank" rel="noopener" href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/file.html">https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/file.html</a>  </p>
<h1 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h1><hr>
<p>在Lua5.1语言中，元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，类似PHP的魔术方法。Python里也有<code>元类(metaclass)</code>一说。  </p>
<p>通过元表，Lua有了更多的扩展特性。Lua的面向对象特性就是基于元表实现的。      </p>
<p>Lua 提供了两个十分重要的用来处理元表的方法，如下：</p>
<ul>
<li><code>setmetatable(table, metatable)</code>：此方法用于为一个表设置元表。</li>
<li><code>getmetatable(table)</code>：此方法用于获取表的元表对象。</li>
</ul>
<p>设置元表的方法很简单，如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mymetatable = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mytable, mymetatable)</span><br></pre></td></tr></table></figure>

<p>上面的代码可以简写成如下的一行代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>


<p>例如我们可以重载 <code>__add</code> 元方法 (metamethod)，实现重载<code>+</code>操作符，来计算两个 Lua 数组的并集：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算集合的并集实例</span></span><br><span class="line">set1 = &#123;<span class="number">10</span>,<span class="number">40</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(set1, &#123;</span><br><span class="line">	<span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, another)</span></span></span><br><span class="line">		<span class="keyword">local</span> res = &#123;&#125;</span><br><span class="line">		<span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">self</span>) <span class="keyword">do</span> set[v] = <span class="literal">true</span> <span class="keyword">end</span> <span class="comment">-- 防止集合元素重复</span></span><br><span class="line">		<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(another) <span class="keyword">do</span> set[v] = <span class="literal">true</span> <span class="keyword">end</span> <span class="comment">-- 防止集合元素重复</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span> <span class="built_in">table</span>.<span class="built_in">insert</span>(res, k) <span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> set3 = set1 + set2</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(set3) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">20</span><br><span class="line">10</span><br><span class="line">40</span><br></pre></td></tr></table></figure>

<p>类似的元方法还有：</p>
<ul>
<li><p><code>__add</code> <code>+</code>操作</p>
</li>
<li><p><code>__sub</code> <code>-</code>操作 其行为类似于 <code>add</code> 操作</p>
</li>
<li><p><code>__mul</code> <code>*</code>操作 其行为类似于 <code>add</code> 操作</p>
</li>
<li><p><code>__div</code> <code>/</code>操作 其行为类似于 <code>add</code> 操作</p>
</li>
<li><p><code>__mod</code> <code>%</code>操作 其行为类似于 <code>add</code> 操作</p>
</li>
<li><p><code>__pow</code> <code>^</code>（幂）操作 其行为类似于 <code>add</code> 操作</p>
</li>
<li><p><code>__unm</code> 一元 <code>-</code> 操作</p>
</li>
<li><p><code>__concat</code> <code>..</code>（字符串连接） 操作</p>
</li>
<li><p><code>__len</code> <code>#</code>操作</p>
</li>
<li><p><code>__eq</code> <code>==</code>操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作，仅在两个对象类型相同且有对应操作相同的元方法时才起效</p>
</li>
<li><p><code>__lt</code> <code>&lt;</code>操作</p>
</li>
<li><p><code>__le</code> <code>&lt;=</code>操作</p>
</li>
<li><p><code>__index</code> 取下标操作用于访问 <code>table[key]</code></p>
</li>
<li><p><code>__newindex</code> 赋值给指定下标 <code>table[key] = value</code></p>
</li>
<li><p><code>__tostring</code> 转换成字符串</p>
</li>
<li><p><code>__call</code> 当 Lua 调用一个值时调用</p>
</li>
<li><p><code>__mode</code> 用于弱表(week table)</p>
</li>
<li><p><code>__metatable</code> 用于保护<code>metatable</code>不被访问</p>
</li>
</ul>
<h2 id="index-元方法"><a href="#index-元方法" class="headerlink" title="__index 元方法"></a>__index 元方法</h2><p>该方法实现了在表中查找键不存在时转而在元表中查找该键的功能。有两种写法：  </p>
<p>第一种是给 <code>__index</code> 元方法一个函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">	<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, key)</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;__index&quot;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(mytable.key1) <span class="comment">-- __index </span></span><br></pre></td></tr></table></figure>

<p>另一种方法是给 <code>__index</code> 元方法一个表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> _M = &#123;</span><br><span class="line">	add = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x+y <span class="keyword">end</span>,</span><br><span class="line">	mul = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x*y <span class="keyword">end</span>,</span><br><span class="line">	ver = <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">local</span> mytable = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">	<span class="built_in">__index</span> = _M</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(mytable.ver) <span class="comment">-- 1.0 </span></span><br><span class="line"><span class="built_in">print</span>(mytable.add(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">-- 4 </span></span><br></pre></td></tr></table></figure>

<p>Lua查找一个表元素时的规则，其实就是如下3个步骤:</p>
<ol>
<li>在表中查找，如果找到，返回该元素，找不到则继续</li>
<li>判断该表是否有元表，如果没有元表，返回<code>nil</code>，有元表则继续。</li>
<li>判断元表有没有<code>__index</code>方法，如果<code>__index</code>方法为<code>nil</code>，则返回<code>nil</code>；如果<code>__index</code>方法是一个表，则重复1、2、3；如果<code>__index</code>方法是一个函数，则返回该函数的返回值。</li>
</ol>
<p>通过<code>__index</code>这个方法，我们可以实现继承的特性。下节再详细讲述。</p>
<h2 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h2><p>如果说<code>__index</code>具有PHP里<code>__get</code>的一些特性，那么<code>__newindex</code>则类似<code>__set</code>。  </p>
<p>以下实例使用了 rawset 函数来更新表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, &#123;</span><br><span class="line">  <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, key, value)</span></span></span><br><span class="line">        <span class="built_in">rawset</span>(<span class="built_in">self</span>, key, <span class="string">&quot;\&quot;&quot;</span>..value..<span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mytable.key1 = <span class="string">&quot;new value&quot;</span></span><br><span class="line">mytable.key2 = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new value    &quot;4&quot;</span><br></pre></td></tr></table></figure>

<h2 id="tostring-元方法"><a href="#tostring-元方法" class="headerlink" title="__tostring 元方法"></a>__tostring 元方法</h2><p>如果设置了__tostring 元方法，当直接输出表时会自动调用该方法。示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = <span class="built_in">setmetatable</span>(&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> &#125;, &#123;</span><br><span class="line">  <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable)</span></span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(mytable) <span class="keyword">do</span></span><br><span class="line">        sum = sum + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(mytable) <span class="comment">-- 60</span></span><br></pre></td></tr></table></figure>

<h2 id="call-元方法"><a href="#call-元方法" class="headerlink" title="__call 元方法"></a>__call 元方法</h2><p>__call 元方法的功能类似于 C++ 中的仿函数，使得普通的表也可以被调用。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, arg)</span></span></span><br><span class="line">	<span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">		sum = sum + v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(sum)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line">mytable(&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;) <span class="comment">-- 60</span></span><br></pre></td></tr></table></figure>

<p>示例里我们调用自定义的表，并给该表传了参数，最终算出了参数的和。</p>
<h2 id="metatable-元方法"><a href="#metatable-元方法" class="headerlink" title="__metatable 元方法"></a>__metatable 元方法</h2><p>如果给表设置了 __metatable 元方法的值，getmetatable 将返回这个域的值，而调用 setmetatable将会被禁止，会直接报错。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="built_in">__metatable</span> = <span class="string">&quot;no access&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(mytable)) <span class="comment">-- no access</span></span><br><span class="line"><span class="built_in">setmetatable</span>(mytable, &#123;&#125;) <span class="comment">-- 引发编译器报错</span></span><br></pre></td></tr></table></figure>

<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><hr>
<p>在Lua 中，我们可以使用表和函数实现面向对象。将函数和相关的数据放置于同一个表中就形成了一个对象。  </p>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- module/cache.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">_M.mt = &#123;&#125;</span><br><span class="line"></span><br><span class="line">_M.set = <span class="function"><span class="keyword">function</span><span class="params">(self, key ,value)</span></span></span><br><span class="line">	<span class="built_in">self</span>.mt[key] = value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">_M.get = <span class="function"><span class="keyword">function</span><span class="params">(self, key)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">self</span>.mt[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">_M.getall = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">self</span>.mt</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">_M.new = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="built_in">__index</span> = _M &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cache = <span class="built_in">require</span> <span class="string">&quot;module/cache&quot;</span></span><br><span class="line"><span class="keyword">local</span> c = cache:new()</span><br><span class="line">c:set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lua&quot;</span>)</span><br><span class="line">c:set(<span class="string">&quot;year&quot;</span>, <span class="number">2018</span>)</span><br><span class="line"><span class="built_in">print</span>(c:get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(c:get(<span class="string">&quot;year&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(c:getall()) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line">2018</span><br><span class="line">name    lua</span><br><span class="line">year    2018</span><br></pre></td></tr></table></figure>

<p><code>setmetatable</code> 将 <code>_M</code> 作为新建表的原型，所以在自己的表内找不到所调用方法和变量的时候，便会到 <code>__index</code> 所指定的 <code>_M</code> 类型中去寻找。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>__index</code>元方法实现了在父类中查找存在的方法和变量的机制。借助这个，可以实现继承。  </p>
<p>还是利用上面的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- module/mycache</span></span><br><span class="line"><span class="keyword">local</span> cache = <span class="built_in">require</span> <span class="string">&quot;module/cache&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">_M.del = <span class="function"><span class="keyword">function</span><span class="params">(self, key)</span></span></span><br><span class="line">	_M.mt[key] = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">_M.new = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">setmetatable</span>(_M, &#123;<span class="built_in">__index</span> = cache &#125;) <span class="comment">--该方法需要覆写父类的，确保此处的setmetatable先执行</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>

<p>此处实现了删除操作。调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cache = <span class="built_in">require</span> <span class="string">&quot;module/mycache&quot;</span></span><br><span class="line"><span class="keyword">local</span> c = cache:new()</span><br><span class="line">c:set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lua&quot;</span>)</span><br><span class="line">c:del(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c:get(<span class="string">&quot;name&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>



<h1 id="Redis里使用Lua"><a href="#Redis里使用Lua" class="headerlink" title="Redis里使用Lua"></a>Redis里使用Lua</h1><hr>
<p>版本：自2.6.0起可用。<br>时间复杂度：取决于执行的脚本。</p>
<p>使用Lua脚本的好处：</p>
<ul>
<li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延。</li>
<li>原子操作。redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。</li>
<li>复用。客户端发送的脚本会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>script</code>是第一个参数，为Lua 5.1脚本。该脚本不需要定义Lua函数（也不应该）。</li>
<li>第二个参数<code>numkeys</code>指定后续参数有几个key。</li>
<li><code>key [key ...]</code>，是要操作的键，可以指定多个，在lua脚本中通过<code>KEYS[1]</code>, <code>KEYS[2]</code>获取</li>
<li><code>arg [arg ...]</code>，参数，在lua脚本中通过<code>ARGV[1]</code>, <code>ARGV[2]</code>获取。</li>
</ul>
<p>简单实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">&quot;return ARGV[1]&quot;</span> 0 100 </span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">&quot;return &#123;ARGV[1],ARGV[2]&#125;&quot;</span> 0 100 101</span><br><span class="line">1) <span class="string">&quot;100&quot;</span></span><br><span class="line">2) <span class="string">&quot;101&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> 2 key1 key2 first second</span><br><span class="line">1) <span class="string">&quot;key1&quot;</span></span><br><span class="line">2) <span class="string">&quot;key2&quot;</span></span><br><span class="line">3) <span class="string">&quot;first&quot;</span></span><br><span class="line">4) <span class="string">&quot;second&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">&quot;redis.call(&#x27;SET&#x27;, KEYS[1], ARGV[1]);redis.call(&#x27;EXPIRE&#x27;, KEYS[1], ARGV[2]); return 1;&quot;</span> 1 <span class="built_in">test</span> 10 60</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl <span class="built_in">test</span></span><br><span class="line">(<span class="built_in">integer</span>) 59</span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li><code>&#123;&#125;</code>在lua里是指数据类型<code>table</code>，类似数组。</li>
<li><code>redis.call()</code>可以调用redis命令。</li>
</ul>
<h3 id="命令行里使用"><a href="#命令行里使用" class="headerlink" title="命令行里使用"></a>命令行里使用</h3><p>如果直接使用<code>redis-cli</code>命令，格式会有点不一样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --<span class="built_in">eval</span> lua_file key1 key2 , arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>注意的地方：</p>
<ul>
<li>eval 后面参数是lua脚本文件,<code>.lua</code>后缀</li>
<li>不用写<code>numkeys</code>，而是使用<code>,</code>隔开。注意<code>,</code>前后有空格。</li>
</ul>
<p>示例：</p>
<p>incrbymul.lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> num = redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">local</span> res = num * ARGV[<span class="number">1</span>]; </span><br><span class="line">	redis.call(<span class="string">&#x27;SET&#x27;</span>,KEYS[<span class="number">1</span>], res); </span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>命令行运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --<span class="built_in">eval</span> incrbymul.lua lua:incrbymul , 8</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">$ redis-cli incr lua:incrbymul </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">$ redis-cli --<span class="built_in">eval</span> incrbymul.lua lua:incrbymul , 8</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">$ redis-cli --<span class="built_in">eval</span> incrbymul.lua lua:incrbymul , 8</span><br><span class="line">(<span class="built_in">integer</span>) 64</span><br><span class="line">$ redis-cli --<span class="built_in">eval</span> incrbymul.lua lua:incrbymul , 2</span><br><span class="line">(<span class="built_in">integer</span>) 128</span><br></pre></td></tr></table></figure>

<p>由于redis没有提供命令可以实现将一个数原子性的乘以N倍，这里我们就用Lua脚本实现了，运行过程中确保不会被其它客户端打断。</p>
<h3 id="phpredis里使用"><a href="#phpredis里使用" class="headerlink" title="phpredis里使用"></a>phpredis里使用</h3><p>接着上面的例子：  </p>
<p>incrbymul.php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="variable">$lua</span> = <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">local num = redis.call(&#x27;GET&#x27;, KEYS[1]);  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if not num then</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">	local res = num * ARGV[1]; </span></span><br><span class="line"><span class="string">	redis.call(&#x27;SET&#x27;,KEYS[1], res); </span></span><br><span class="line"><span class="string">	return res;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="variable">$ret</span> = <span class="variable">$redis</span>-&gt;<span class="keyword">eval</span>(<span class="variable">$lua</span>, <span class="keyword">array</span>(<span class="string">&quot;lua:incrbymul&quot;</span>, <span class="number">2</span>), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$ret</span>;</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli <span class="built_in">set</span> lua:incrbymul 0</span><br><span class="line">OK</span><br><span class="line">$ redis-cli incr lua:incrbymul</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">$ php incrbymul.php </span><br><span class="line">2</span><br><span class="line">$ php incrbymul.php </span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>eval原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis::eval(<span class="built_in">string</span> script, [<span class="built_in">array</span> keys, <span class="type">long</span> num_keys])</span><br></pre></td></tr></table></figure>

<p>eval函数的第3个参数为KEYS个数，phpredis依据此值将KEYS和ARGV做区分。</p>
<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p>1、在redis中使用lua脚本让你的灵活性提高5个逼格 - 一线码农 - 博客园<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangxincheng/p/6230129.html">https://www.cnblogs.com/huangxincheng/p/6230129.html</a><br>2、Redis执行Lua脚本示例 - yanghuahui - 博客园<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanghuahui/p/3697996.html">https://www.cnblogs.com/yanghuahui/p/3697996.html</a><br>3、EVAL - Redis<br><a target="_blank" rel="noopener" href="https://redis.io/commands/eval">https://redis.io/commands/eval</a><br>4、phpredis 执行LUA脚本的例子 - jingtan的专栏 - CSDN博客<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jingtan/article/details/53392309">https://blog.csdn.net/jingtan/article/details/53392309</a>  </p>
<h1 id="Ngx-lua"><a href="#Ngx-lua" class="headerlink" title="Ngx_lua"></a>Ngx_lua</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>ngx_lua 指的是 <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module"><code>lua-nginx-module</code></a>模块：通过将 <code>LuaJIT</code> 的虚拟机嵌入到 Nginx 的 worker 中，这样既保持高性能，又能不失去lua开发的简单特性。  </p>
<p><code>OpenResty</code> 就是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。OpenResty 基于<code>Nginx</code>开发，可以简单认为是 <code>Nginx</code> + <code>lua-nginx-module</code>的组合版。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://openresty.org/cn/">https://openresty.org/cn/</a><br>官方文档：<a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module">https://github.com/openresty/lua-nginx-module</a>  </p>
<h2 id="Hello-World-1"><a href="#Hello-World-1" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="OpenResty-安装"><a href="#OpenResty-安装" class="headerlink" title="OpenResty 安装"></a>OpenResty 安装</h3><p>以 CentOS 为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt &amp;&amp; <span class="built_in">cd</span> /opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># download openresty</span></span><br><span class="line">wget https://openresty.org/download/openresty-1.13.6.2.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf openresty-1.13.6.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openresty-1.13.6.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure</span></span><br><span class="line">./configure --prefix=/usr/local/openresty -j4</span><br><span class="line"></span><br><span class="line">make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>其中 源码包可以到 <a target="_blank" rel="noopener" href="https://openresty.org/cn/download.html">https://openresty.org/cn/download.html</a> 该页面获取。<br><code>-j4</code>表示使用4核。<code>configure</code>那一步还可以指定各种参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/openresty \</span><br><span class="line">            --with-luajit \</span><br><span class="line">            --without-http_redis2_module \</span><br><span class="line">            --with-http_iconv_module \</span><br><span class="line">            --with-http_postgres_module</span><br></pre></td></tr></table></figure>

<p>使用 <code>./configure --help</code> 查看更多的选项。</p>
<p>其它系统环境上安装可以参考 <a target="_blank" rel="noopener" href="https://openresty.org/cn/installation.html">https://openresty.org/cn/installation.html</a> 。</p>
<p>其实安装 OpenResty 和安装 Nginx 是类似的，因为 OpenResty 是基于 Nginx 开发的。</p>
<p>如果已经安装了 Nginx，又想使用 OpenResty 的功能，可以参考  《Nginx编译安装Lua》：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/52fhy/p/10164553.html">https://www.cnblogs.com/52fhy/p/10164553.html</a> 一文安装<code>lua-nginx-module</code>模块即可。</p>
<h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><p>修改 <code>/usr/local/openresty/nginx/conf/nginx.conf</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">error_log logs/error.log;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        location /hello &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            content_by_lua &#x27;</span><br><span class="line">                ngx.say(&quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;)</span><br><span class="line">            &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把默认的<code>80</code>端口改为<code>8080</code>，新增<code>/hello</code>部分。</p>
<p>其中<code>content_by_lua</code>便是 OpenResty 提供的指令，在官方文档可以搜索到：</p>
<p><img src="http://img2018.cnblogs.com/blog/663847/201903/663847-20190324174956312-276962073.png"></p>
<p>现在我们启动OpenResty：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/openresty/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<p>启动成功后，查看效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/hello</span><br><span class="line">&lt;p&gt;hello, world&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>说明成功运行了。</p>
<h2 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h2><p>1、OpenResty® - 中文官方站<br><a target="_blank" rel="noopener" href="https://openresty.org/cn/">https://openresty.org/cn/</a><br>2、openresty&#x2F;lua-nginx-module: Embed the Power of Lua into NGINX HTTP servers<br><a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module#version">https://github.com/openresty/lua-nginx-module#version</a><br>3、环境搭建 · OpenResty最佳实践<br><a target="_blank" rel="noopener" href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/openresty/install.html">https://moonbingbing.gitbooks.io/openresty-best-practices/content/openresty/install.html</a>  </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">pixel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/07/lua%E5%9F%BA%E7%A1%80/">http://example.com/2025/02/07/lua%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">pixel博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/">脚本语言</a></div><div class="post-share"><div class="social-share" data-image="/image/lbxx.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/02/07/c-%E5%9F%BA%E7%A1%80/" title="cpp基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">cpp基础</div></div><div class="info-2"><div class="info-item-1">C++编程基础Hello, world!12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;stdlib.h&gt;  //使用atexit()using namespace std;void show1(void) &#123;	cout &lt;&lt; &quot;first exit main()&quot; &lt;&lt; endl;&#125;void show2(void) &#123;	cout &lt;&lt; &quot;second exit main()&quot; &lt;&lt; endl;&#125;int main(int argc, char* argv[]) &#123;	atexit(show1);    atexit(show2);	cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	return...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/lbxx.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">pixel</div><div class="author-info-description">啥都写，仅自用！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.1.</span> <span class="toc-text">Linux 系统上安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mac-OS-X-%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.</span> <span class="toc-text">Mac OS X 系统上安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85-Lua"><span class="toc-number">1.1.3.</span> <span class="toc-text">Window 系统上安装 Lua</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-%E5%92%8C-LuaJIT-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.</span> <span class="toc-text">Lua 和 LuaJIT 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenResty-%E4%B8%8E-Lua%E3%80%81LuaJIT"><span class="toc-number">1.1.5.</span> <span class="toc-text">OpenResty 与 Lua、LuaJIT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-World"><span class="toc-number">1.2.1.</span> <span class="toc-text">Hello World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">标示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">关键词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">变量定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">1.3.</span> <span class="toc-text">拓展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nil"><span class="toc-number">2.1.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boolean"><span class="toc-number">2.2.</span> <span class="toc-text">boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#number"><span class="toc-number">2.3.</span> <span class="toc-text">number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">2.4.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table"><span class="toc-number">2.5.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function"><span class="toc-number">2.6.</span> <span class="toc-text">function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#userdata"><span class="toc-number">2.7.</span> <span class="toc-text">userdata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread"><span class="toc-number">2.8.</span> <span class="toc-text">thread</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text">其它运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.</span> <span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else"><span class="toc-number">4.1.</span> <span class="toc-text">if-else</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while"><span class="toc-number">4.2.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for"><span class="toc-number">4.3.</span> <span class="toc-text">for</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E6%95%B0%E5%AD%97%E5%9E%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">for 数字型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">for 泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break"><span class="toc-number">4.4.</span> <span class="toc-text">break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#return"><span class="toc-number">4.5.</span> <span class="toc-text">return</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">函数动态调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">6.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-1"><span class="toc-number">6.1.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%8F%B7%E4%B8%8E%E5%86%92%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">点号与冒号操作符的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.</span> <span class="toc-text">常用库介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E5%BA%93"><span class="toc-number">7.1.</span> <span class="toc-text">String 库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">7.1.1.</span> <span class="toc-text">字符串格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Table-%E5%BA%93"><span class="toc-number">7.2.</span> <span class="toc-text">Table 库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%BA%93"><span class="toc-number">7.3.</span> <span class="toc-text">日期时间库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%BA%93"><span class="toc-number">7.4.</span> <span class="toc-text">数学库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">7.5.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">简单模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">完全模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83-1"><span class="toc-number">8.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%83%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">元表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#index-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">__index 元方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newindex-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">__newindex 元方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tostring-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">__tostring 元方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">__call 元方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#metatable-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.</span> <span class="toc-text">__metatable 元方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">10.1.</span> <span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%87%8C%E4%BD%BF%E7%94%A8Lua"><span class="toc-number">11.</span> <span class="toc-text">Redis里使用Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%87%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.2.</span> <span class="toc-text">命令行里使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phpredis%E9%87%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.3.</span> <span class="toc-text">phpredis里使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83-2"><span class="toc-number">11.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ngx-lua"><span class="toc-number">12.</span> <span class="toc-text">Ngx_lua</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">12.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-World-1"><span class="toc-number">12.2.</span> <span class="toc-text">Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenResty-%E5%AE%89%E8%A3%85"><span class="toc-number">12.2.1.</span> <span class="toc-text">OpenResty 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">12.2.2.</span> <span class="toc-text">第一个程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83-3"><span class="toc-number">12.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/07/lua%E5%9F%BA%E7%A1%80/" title="lua基础">lua基础</a><time datetime="2025-02-07T10:45:45.000Z" title="发表于 2025-02-07 18:45:45">2025-02-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/07/c-%E5%9F%BA%E7%A1%80/" title="cpp基础">cpp基础</a><time datetime="2025-02-07T08:41:27.000Z" title="发表于 2025-02-07 16:41:27">2025-02-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络-应用层">计算机网络-应用层</a><time datetime="2025-02-06T15:55:11.000Z" title="发表于 2025-02-06 23:55:11">2025-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/" title="计算机网络-运输层">计算机网络-运输层</a><time datetime="2025-02-06T15:54:01.000Z" title="发表于 2025-02-06 23:54:01">2025-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络-网络层">计算机网络-网络层</a><time datetime="2025-02-06T14:36:51.000Z" title="发表于 2025-02-06 22:36:51">2025-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By pixel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/styles/fish.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>